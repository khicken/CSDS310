#import "@preview/lovelace:0.3.0": pseudocode-list
#set enum(numbering: "a)")

#set align(right)
Kaleb Kim \
12/1/24

#set align(center)
= CSDS 310 Assignment 4 v2
#set align(left)

_Note: Arrays are zero-indexed._

== Problem 1
+ $checkmark$
+ *Counterexample*: Consider activities $a_1 = [1, 4], a_2 = [4, 7], "and" a_3 = [4, 5]$. The greedy solution is ${a_3}$, since $a_3$ has the shortest duration. However, the optimal solution is ${a_1, a_2}$.
+ *Counterexample*: Consider activities $a_1 = [1, 3], a_2 = [3, 5], a_3 = [5, 7], a_4 = a_5 = [2, 4], a_6=a_7=[4,6]$. Here, the greedy solution does the following:
  - $a_1$ or $a_3$ is selected since each have the fewest overlaps of 2.
  - If $a_1$ is selected, then $a_6$ or $a_7$ is selected since each have the fewest overlaps of 3. If $a_3$ is selected, then $a_4$ or $a_5$ is selected by the same logic.
  - No other activities can be run. The algorithm terminates, which means that the greedy solution only generates sets of length two. These sets are ${a_1, a_6}, {a_1, a_7}, {a_3, a_4}, "and" {a_3, a_5}$. 
  However, the optimal solution is ${a_1, a_2, a_3}$.
\
== Problem 2
=== Pseudocode
#pseudocode-list[
+ *procedure* MAX_PROFIT(A, B, n):
  + r-quicksort A
  + r-quicksort B
  + profit $<-$ 1
  + *for* $0 <= i < n$:
    + profit $<-$ profit $times$ $A[i]^B[i]$
  + *return* profit
]

=== Proof
Let $A = {a_1, ..., a_n}$ and $B = {b_1, ..., b_n}$. Let $p$ be the payout generated by the greedy algorithm, and $p'$ be an arbitrary payout from a general solution.

In the greedy algorithm, we have $A$ and $B$ sorted in ascending order. To prove with exch

=== Runtime
Randomized quick sort takes $O(n log n)$ time in the worst case. It also sorts in place, using $O(1)$ extra space. The for loop runs for $Theta(n)$ time. Thus, we have:
$
&"Time complexity: " O(n log n) \
&"Space complexity: " O(1)
$

== Problem 3
// Schedule $n $activities, each requiring $t_i $time and with a deadline $d_i$, to minimize the maximum delay $\max(\Delta_i)$

=== Algorithm
   - Sort activities by their deadlines $d_i $in ascending order.
   - Start scheduling from $t=0$, assigning $s_i = max(t, 0) $and updating $t = s_i + t_i$

=== Example
   - Input: $t = [10, 5, 6, 2], d = [11, 6, 12, 20]$
   - Sorted by deadlines: $\{(5, 6), (10, 11), (6, 12), (2, 20)\}$
   - Scheduled order: $[2, 1, 3, 4]$
   - Starting/Finishing times: $[0/5, 5/15, 15/21, 21/23]$
   - Maximum delay: $Delta = max(-1, 4, 9, -3) = 9$

=== Explanation
- Sorting by deadlines minimizes delays, ensuring earlier deadlines are prioritized.

== Problem 4
+ We must prove that if the coin denominations are powers of 2, then this greedy choice leads to the optimal solution. Let $a$ represent the coins needed to make $n$ based on the greedy choice.
  - Base case: \ When $n=1$, we have $c = [1]$ so $a=1$ (coins = ${1}$). \ When $n=2$, we have $c=[1,2]$ so that $a=1$ (coins = ${2}$). \ When $n=2$, we have $c=[1,2]$ so that $a=1$ (coins = ${2, 1}$).
  - Inductive step: Having proven that $a$ is optimal for $1<=n<=b$ such that $b=3$, we must prove $b+1$. From our base case, we notice that for the largest coin $c_k$, we have $k = floor(log_2(b))$. Then, we have $k'=floor(log_2(b+1))$. This means that if $b+1$ can be expressed as $2^d$ with $d in ZZ$, we have $a'=a-c_k'$, another optimal solution. This also works for cases in which $b+1$ cannot be expressed as such. Therefore, the greedy solution is always optimal for $n$.